/**
 * @file offb_node.cpp
 * @brief Offboard control, for UAV autonomous navigation control
 */

#include <ros/ros.h>
#include <XmlRpcValue.h>
#include <unordered_map>
#include <signal.h>
#include <Eigen/Geometry>
#include <tf/tf.h>

#include <geometry_msgs/PoseStamped.h>
#include <geometry_msgs/TwistStamped.h>
#include <mavros_msgs/CommandBool.h>
#include <mavros_msgs/SetMode.h>
#include <mavros_msgs/State.h>
#include <mavros_msgs/ParamSet.h>
#include <mavros_msgs/ParamGet.h>
#include <mavros_msgs/ParamValue.h>

#include <actionlib/server/simple_action_server.h>
#include <navigation_3d_msgs/PathNavigationAction.h>

class OffboardControl 
{
  typedef geometry_msgs::PoseStamped Pose;
  typedef geometry_msgs::TwistStamped Twist;
  enum MOVING_STATE {
    INIT,
    FOLLOW,
    PAUSE
  } moving_state;

  ros::NodeHandle private_nh;
  ros::NodeHandle mavros_nh;  // should be consist with the name of mavros_node  

  mavros_msgs::State current_state;
  // mavros_msgs::
  // custom_param_dict to store parameters set by custom in ~/custom_param
  // fcu_param_dict to store original value of parameters in FCU to re-write into fcu when out of offbodard mode
  XmlRpc::XmlRpcValue custom_param_dict;

  std::unordered_map<std::string, mavros_msgs::ParamValue> custom_parameters;
  std::unordered_map<std::string, mavros_msgs::ParamValue> origin_paramters_in_fcu;
  Pose set_pose;
  Pose generated_pose;  /* generated by planner in executCB */
  Pose local_pose;
  Twist local_velocity;

  ros::Rate rate_wait;
  ros::Rate rate_send;

  bool custom_param_seted;  /* true if custom param has been set to FCU */
  bool set_pause_pose;
  
  double pub_frequency; /* frequency of set point publish to FCU */
  double reached_condition; /* the distance condition of reaching a set point */
  double sphere_r;  /* the distance that indeicate near the line between waypoints */

  ros::Subscriber state_sub;
  ros::Subscriber local_pose_sub;
  ros::Subscriber local_velocity_sub;

  ros::Publisher set_position_pub;

  ros::ServiceClient arming_client;
  ros::ServiceClient set_mode_client;
  ros::ServiceClient set_param;
  ros::ServiceClient get_param;

  actionlib::SimpleActionServer<navigation_3d_msgs::PathNavigationAction>* as_;
  navigation_3d_msgs::PathNavigationResult result;
  navigation_3d_msgs::PathNavigationFeedback feedback;

  std::string action_server_name;

  void stateCB(const mavros_msgs::State::ConstPtr&);
  void localPositionCB(const Pose::ConstPtr&);
  void localVelocityCB(const Twist::ConstPtr&);
  void setFCUParam(std::unordered_map<std::string, mavros_msgs::ParamValue> const&);
  void updateParamList();
  void pubTimerCB(const ros::TimerEvent&);
  bool planner(const Pose&, const Pose&);
  bool isQuaternionValid(const geometry_msgs::Quaternion&);

public:
  OffboardControl();
  ~OffboardControl() {}
  void spin();
  void cleanBeforeExit();
  void executeCB(const navigation_3d_msgs::PathNavigationGoalConstPtr&);
};

OffboardControl::OffboardControl():
  moving_state(MOVING_STATE::INIT),
  private_nh("~"),
  mavros_nh("mavros"),
  rate_wait(1.0),
  rate_send(20.0),
  custom_param_seted(false),
  set_pause_pose(false),
  as_(nullptr) 
{
  
  state_sub = mavros_nh.subscribe<mavros_msgs::State> 
    ("state", 10, &OffboardControl::stateCB, this);
  local_pose_sub = mavros_nh.subscribe<Pose> 
    ("local_position/pose", 10, &OffboardControl::localPositionCB, this);
  local_velocity_sub = mavros_nh.subscribe<Twist> 
    ("local_position/velocity", 10, &OffboardControl::localVelocityCB, this);

  set_position_pub = mavros_nh.advertise<Pose> 
    ("setpoint_position/local", 10);

  arming_client = mavros_nh.serviceClient<mavros_msgs::CommandBool> ("cmd/arming");
  set_mode_client = mavros_nh.serviceClient<mavros_msgs::SetMode> ("set_mode");
  set_param = mavros_nh.serviceClient<mavros_msgs::ParamSet> ("param/set");
  get_param = mavros_nh.serviceClient<mavros_msgs::ParamGet> ("param/get");

  private_nh.param<double>("pub_frequency", pub_frequency, 10.0);
  if (pub_frequency < 2.0){
    pub_frequency = 2.0;
    ROS_WARN("OFFBOARD: The minimum frequency of set point publish is 2Hz");
  }

  private_nh.param<double>("reached_condition", reached_condition, 0.1);
  private_nh.param<double>("near_line_distance", sphere_r, 0.2);
  private_nh.param<std::string>("action_server_name", action_server_name, "move_base");

  as_ = new actionlib::SimpleActionServer<navigation_3d_msgs::PathNavigationAction>
    (private_nh, action_server_name, boost::bind(&OffboardControl::executeCB, this, _1), false);

  as_->start();
}

void OffboardControl::updateParamList()
{  
  // wait for SYS_PARAM_VER updated, if update, meas ROS get parameter from FCU
  mavros_msgs::ParamGet fcu_param;
  fcu_param.request.param_id = "SYS_PARAM_VER";
  do{
    get_param.call(fcu_param);
    ros::spinOnce();
    ROS_INFO("OFFBOARD: Wait for FCU parameters!");
    rate_wait.sleep();
  }
  while (ros::ok() && !fcu_param.response.success);
  
  // load parameters value from FCU (those are needed to be setting) and store
  if (private_nh.getParam("custom_param", custom_param_dict)){
    ROS_ASSERT(custom_param_dict.getType() == XmlRpc::XmlRpcValue::TypeStruct);

    for (auto &it : custom_param_dict) {
      fcu_param.request.param_id = it.first;
      if (get_param.call(fcu_param)) {
        if (fcu_param.response.success){ // find paramter in fcu
          origin_paramters_in_fcu[it.first] = fcu_param.response.value;

          mavros_msgs::ParamValue temp_param_value;
          switch (it.second.getType()) {
          case XmlRpc::XmlRpcValue::TypeBoolean:
          case XmlRpc::XmlRpcValue::TypeInt:
            temp_param_value.integer = static_cast<int>(it.second);
            temp_param_value.real = 0.0;
            break;
          case XmlRpc::XmlRpcValue::TypeDouble:
            temp_param_value.integer = 0;
            temp_param_value.real = static_cast<double>(it.second);
            break;
          default:
            ROS_WARN_NAMED("param", "PR: Unsupported XmlRpcValue type: %u", it.second.getType());
          }
          custom_parameters[it.first] = temp_param_value;
        }
      }
    }
  }

  ROS_INFO("OFFBOARD: Custom FCU parameters list loaded!");
}

void OffboardControl::cleanBeforeExit()
{
  ROS_INFO("OFFBOARD: Cleanning OffboardControl ...");
  if (custom_param_seted){
    setFCUParam(origin_paramters_in_fcu);
  }
}

void OffboardControl::executeCB(const navigation_3d_msgs::PathNavigationGoalConstPtr & goal)
{
  /* this cb mainly get current setpoint */
  std::vector<Pose> waypoints;
  waypoints = goal->path;
  int wp_number = waypoints.size();
  int current_number = 0;
  Pose pre_wp, current_wp;

  ros::Rate rate_generate_pose(20);
  ROS_INFO("OFFBOARD: Get new goal!");
  while (!ros::isShuttingDown()) {
    
    if (!current_state.armed) {
      moving_state = MOVING_STATE::INIT;
      as_->setAborted(result,"Aborting this goal, because it is not disarmed");
      return;
    }

    /* the first wp */
    current_wp = waypoints[current_number];

    if (!isQuaternionValid(current_wp.pose.orientation)){
      char* message;
      sprintf(message, "Aborting on Pose Num %d because it was sent with an invalid quaternion", current_number);
      as_->setAborted(result,message);
      moving_state = MOVING_STATE::PAUSE;
      return;
    }

    moving_state = MOVING_STATE::FOLLOW;
    if (current_number == 0) pre_wp = current_wp;
    else pre_wp = waypoints[current_number-1];

    bool reached  = planner(pre_wp, current_wp);

    feedback.base_position = local_pose;

    if (reached) {
      ROS_WARN("Reached one waypoint!");
      if (current_number < wp_number-1){
        current_number ++;
        /* set feedback */
        as_->publishFeedback(feedback);        
      } else {/* finish all waypoint */
        as_->publishFeedback(feedback);
        as_->setSucceeded(result, "Finish goal, loiting in last waypoint");
        ROS_WARN("Finish goal");
        return;
      }
    }
    rate_generate_pose.sleep();
  }
  as_->setAborted(result, "Aborting on the goal because the node is shutting down");
}

bool OffboardControl::isQuaternionValid(const geometry_msgs::Quaternion& q)
{
  //first we need to check if the quaternion has nan's or infs
  if(!std::isfinite(q.x) || !std::isfinite(q.y) || !std::isfinite(q.z) || !std::isfinite(q.w)){
    ROS_ERROR("Quaternion has nans or infs... discarding as a navigation goal");
    return false;
  }

  tf::Quaternion tf_q(q.x, q.y, q.z, q.w);

  //next, we need to check if the length of the quaternion is close to zero
  if(tf_q.length2() < 1e-6){
    ROS_ERROR("Quaternion has length close to zero... discarding as navigation goal");
    return false;
  }

  //next, we'll normalize the quaternion and check that it transforms the vertical vector correctly
  tf_q.normalize();

  tf::Vector3 up(0, 0, 1);

  double dot = up.dot(up.rotate(tf_q.getAxis(), tf_q.getAngle()));

  if(fabs(dot - 1) > 1e-3){
    ROS_ERROR("Quaternion is invalid... for navigation the z-axis of the quaternion must be close to vertical.");
    return false;
  }

  return true;
}

bool OffboardControl::planner(const Pose &pre_wp, const Pose &current_wp)
//bool near = cross_sphere_line(pos_s, 1.0f, prev_sp_s, curr_sp_s, pos_sp_s);
{
  Eigen::Vector3d res;
  Eigen::Vector3d sphere_c(local_pose.pose.position.x, local_pose.pose.position.y, local_pose.pose.position.z);
  Eigen::Vector3d line_a(pre_wp.pose.position.x, pre_wp.pose.position.y, pre_wp.pose.position.z);
  Eigen::Vector3d line_b(current_wp.pose.position.x, current_wp.pose.position.y, current_wp.pose.position.z);

  generated_pose = current_wp; /* default as current waypoint */

  if((sphere_c - line_b).norm() < reached_condition){
    return true;
  } else {

    /* project center of sphere on line */
    /* normalized AB */
    Eigen::Vector3d ab_norm = line_b - line_a;

    if (ab_norm.norm() < 0.01) {
      return false;
    }

    ab_norm.normalize();
    Eigen::Vector3d d = line_a + ab_norm * (sphere_c - line_a).dot(ab_norm);
    float cd_len = (sphere_c - d).norm();

    if (sphere_r > cd_len) {
      /* we have triangle CDX with known CD and CX = R, find DX */
      float dx_len = sqrtf(sphere_r * sphere_r - cd_len * cd_len);

      if ((sphere_c - line_b).dot(ab_norm) > 0.0) {
        /* target waypoint is already behind us */
        res = line_b;
      } else {
        /* target is in front of us */
        res = d + ab_norm * dx_len; // vector A->B on line
      }
    } else {
      /* have no roots, return D */
      res = d; /* go directly to line */

      /* previous waypoint is still in front of us */
      if ((sphere_c - line_a).dot(ab_norm) < 0.0) {
        res = line_a;
      }
      /* target waypoint is already behind us */
      if ((sphere_c - line_b).dot(ab_norm) > 0.0) {
        res = line_b;
      }
    }

    geometry_msgs::Point position_sp;
    position_sp.x = res(0);
    position_sp.y = res(1);
    position_sp.z = res(2);
    generated_pose.pose.position = position_sp;
    return false;
  }
}

void OffboardControl::setFCUParam(std::unordered_map<std::string, mavros_msgs::ParamValue> const& param_dict)
{
  for (auto &it : param_dict) {
    mavros_msgs::ParamSet temp_param_set;
    temp_param_set.request.param_id = it.first;
    temp_param_set.request.value = it.second;
    set_param.call(temp_param_set);
    if (!temp_param_set.response.success){
        ROS_INFO("OFFBOARD: Parameter set error!");
    }
  }
}

void OffboardControl::stateCB(const mavros_msgs::State::ConstPtr& msg)
{
  // update parameters when offboard mode switched in or out
  if(current_state.mode != "OFFBOARD" && msg->mode == "OFFBOARD"){
    setFCUParam(custom_parameters);
    custom_param_seted = true;
      
  } else if(current_state.mode == "OFFBOARD" && msg->mode != "OFFBOARD") {
    setFCUParam(origin_paramters_in_fcu);
    custom_param_seted = false;
  }

  current_state = *msg;
}

void OffboardControl::localPositionCB(const Pose::ConstPtr& msg)
{
  local_pose = *msg;
}

void OffboardControl::localVelocityCB(const Twist::ConstPtr& msg)
{
  local_velocity = *msg;
}

void OffboardControl::pubTimerCB(const ros::TimerEvent& event)
{

  if (current_state.mode == "OFFBOARD" && !as_->isActive()){
    moving_state = MOVING_STATE::PAUSE;
  }

  switch (moving_state) {
    case MOVING_STATE::PAUSE:
      if (!set_pause_pose) {
        set_pose = local_pose;
        set_pause_pose = true;
      }
      break;
    case MOVING_STATE::FOLLOW:
      set_pose = generated_pose;
      break;
    case MOVING_STATE::INIT:
    default: 
      set_pose = local_pose;
      break;      
  }

  set_position_pub.publish(set_pose);
}

void OffboardControl::spin()
{
  // wait for FCU connection
  while(ros::ok() && !current_state.connected ){
      ros::spinOnce();
      ROS_INFO("OFFBOARD: Wait for FCU connection!");
      rate_wait.sleep();
  }

  updateParamList();

	ros::AsyncSpinner spinner(2 /* threads */);
	auto control_pub_timer = private_nh.createTimer(
			ros::Duration(1.0/pub_frequency), /* set as frequency */
			&OffboardControl::pubTimerCB, this);

	control_pub_timer.start();

	spinner.start();
	ros::waitForShutdown();

  ROS_INFO("OFFBOARD: Stopping OffboardControl...");
	spinner.stop();
}

static OffboardControl* offboard_control_ptr = nullptr;

void sigintHandle(int sig)
{
  ROS_INFO("OFFBOARD: Processing clean work before shutdown!");
  if (offboard_control_ptr != nullptr){
    // delete offboard_control_ptr; // call deconstructor
    offboard_control_ptr->cleanBeforeExit();
  }
  ros::shutdown();
}

int main(int argc, char **argv)
{
  /* code */
  ros::init(argc, argv, "offboard", ros::init_options::NoSigintHandler);

  signal(SIGINT, sigintHandle);

  offboard_control_ptr = new OffboardControl;
  offboard_control_ptr->spin();
  return 0;
}
