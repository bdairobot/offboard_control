/**
 * @file offb_node.cpp
 * @brief Offboard control, for UAV autonomous navigation control
 */

#include <ros/ros.h>
#include <XmlRpcValue.h>
#include <unordered_map>
#include <signal.h>
// #include <Eigen/Geometry>
#include <tf/tf.h>

#include <geometry_msgs/PoseStamped.h>
#include <geometry_msgs/TwistStamped.h>
#include <mavros_msgs/CommandBool.h>
#include <mavros_msgs/SetMode.h>
#include <mavros_msgs/State.h>
#include <mavros_msgs/ParamSet.h>
#include <mavros_msgs/ParamGet.h>
#include <mavros_msgs/ParamValue.h>

#include <actionlib/server/simple_action_server.h>
#include <offboard_control/PathNavigationAction.h>

class OffboardControl 
{
  typedef geometry_msgs::PoseStamped Pose;
  typedef geometry_msgs::TwistStamped Twist;
  enum MOVING_STATE {
    INIT, // UAV still on the ground
    PAUSE, // UAV in Offboard mode but puse at current position
    // FOLLOW_POS,  // UAV follow set point position
    // FOLLOW_VEL, // UAV follow set point velocity
    FOLLOW_PATH  // UAV follow a given path
  } moving_state;

  ros::NodeHandle private_nh;
  ros::NodeHandle mavros_nh;  // should be consist with the name of mavros_node  

  mavros_msgs::State current_state;
  // mavros_msgs::
  // custom_param_dict to store parameters set by custom in ~/custom_param
  // fcu_param_dict to store original value of parameters in FCU to re-write into fcu when out of offbodard mode
  XmlRpc::XmlRpcValue custom_param_dict;

  std::unordered_map<std::string, mavros_msgs::ParamValue> custom_parameters;
  std::unordered_map<std::string, mavros_msgs::ParamValue> origin_paramters_in_fcu;
  Pose set_pose;
  Twist set_vel;
  // Pose set_pose;  /* generated by pose_generate */
  Pose local_pose;
  Twist local_velocity;

  ros::Rate rate_wait;
  ros::Rate rate_send;

  bool custom_param_seted;  /* true if custom param has been set to FCU */
  bool set_pause_pose;

  actionlib::SimpleActionServer<offboard_control::PathNavigationAction>* as_;
  offboard_control::PathNavigationResult result;
  offboard_control::PathNavigationFeedback feedback;
  std::string action_server_name;
  
  double pub_frequency; /* frequency of set point publish to FCU */
  double reached_condition; /* the distance condition of reaching a set point */
  double yaw_reached_condition;
  double sphere_r;  /* the distance that indeicate near the line between waypoints */

  ros::Subscriber state_sub;
  ros::Subscriber local_pose_sub;
  ros::Subscriber local_velocity_sub;

  ros::Publisher set_position_pub;
  ros::Publisher set_velocity_pub;

  ros::ServiceClient arming_client;
  ros::ServiceClient set_mode_client;
  ros::ServiceClient set_param;
  ros::ServiceClient get_param;

  void stateCB(const mavros_msgs::State::ConstPtr&);
  void localPositionCB(const Pose::ConstPtr&);
  void localVelocityCB(const Twist::ConstPtr&);
  void setFCUParam(std::unordered_map<std::string, mavros_msgs::ParamValue> const&);
  void updateParamList();
  void pubTimerCB(const ros::TimerEvent&);
  geometry_msgs::Point pose_generate(const geometry_msgs::Point&, const geometry_msgs::Point&);
  bool isQuaternionValid(const geometry_msgs::Quaternion&);
  bool yawReached(geometry_msgs::Quaternion const &);
  bool yawReached(geometry_msgs::Point const&, geometry_msgs::Point const&, double &);
  bool posReached(const Pose&);

public:
  OffboardControl();
  ~OffboardControl() {}
  void spin();
  void cleanBeforeExit();
  void executeCB(const offboard_control::PathNavigationGoalConstPtr&);
  // void preemptCB(void);
};

OffboardControl::OffboardControl():
  moving_state(MOVING_STATE::INIT),
  private_nh("~"),
  mavros_nh("mavros"),
  rate_wait(1.0),
  rate_send(20.0),
  custom_param_seted(false),
  set_pause_pose(false),
  as_(nullptr) 
{
  
  state_sub = mavros_nh.subscribe<mavros_msgs::State> 
    ("state", 10, &OffboardControl::stateCB, this);
  local_pose_sub = mavros_nh.subscribe<Pose> 
    ("local_position/pose", 10, &OffboardControl::localPositionCB, this);
  local_velocity_sub = mavros_nh.subscribe<Twist> 
    ("local_position/velocity", 10, &OffboardControl::localVelocityCB, this);

  set_position_pub = mavros_nh.advertise<Pose> 
    ("setpoint_position/local", 10);

  arming_client = mavros_nh.serviceClient<mavros_msgs::CommandBool> ("cmd/arming");
  set_mode_client = mavros_nh.serviceClient<mavros_msgs::SetMode> ("set_mode");
  set_param = mavros_nh.serviceClient<mavros_msgs::ParamSet> ("param/set");
  get_param = mavros_nh.serviceClient<mavros_msgs::ParamGet> ("param/get");

  private_nh.param<double>("pub_frequency", pub_frequency, 10.0);
  if (pub_frequency < 2.0){
    pub_frequency = 2.0;
    ROS_WARN("OFFBOARD: The minimum frequency of set point publish is 2Hz");
  }

  private_nh.param<double>("reached_condition", reached_condition, 0.1);
  private_nh.param<double>("yaw_reached_condition",yaw_reached_condition, 10);
  yaw_reached_condition /= 180.0/3.14;
  private_nh.param<double>("near_line_distance", sphere_r, 0.2);
  if (reached_condition > sphere_r) reached_condition = sphere_r; /* constrain reached condition */

  private_nh.param<std::string>("action_server_name", action_server_name, "/move_base");
  as_ = new actionlib::SimpleActionServer<offboard_control::PathNavigationAction>
    (private_nh, action_server_name, boost::bind(&OffboardControl::executeCB, this, _1), false);
  // as_->registerPreemptCallback(boost::bind(&OffboardControl::preemptCB, this));
  as_->start();

}

void OffboardControl::updateParamList()
{  
  // wait for SYS_PARAM_VER updated, if update, meas ROS get parameter from FCU
  mavros_msgs::ParamGet fcu_param;
  fcu_param.request.param_id = "SYS_PARAM_VER";
  do{
    get_param.call(fcu_param);
    ros::spinOnce();
    ROS_INFO("OFFBOARD: Wait for FCU parameters!");
    rate_wait.sleep();
  }
  while (ros::ok() && !fcu_param.response.success);
  
  // load parameters value from FCU (those are needed to be setting) and store
  if (private_nh.getParam("custom_px4_param", custom_param_dict)){
    ROS_ASSERT(custom_param_dict.getType() == XmlRpc::XmlRpcValue::TypeStruct);

    for (auto &it : custom_param_dict) {
      fcu_param.request.param_id = it.first;
      if (get_param.call(fcu_param)) {
        if (fcu_param.response.success){ // find paramter in fcu
          origin_paramters_in_fcu[it.first] = fcu_param.response.value;

          mavros_msgs::ParamValue temp_param_value;
          switch (it.second.getType()) {
          case XmlRpc::XmlRpcValue::TypeBoolean:
          case XmlRpc::XmlRpcValue::TypeInt:
            temp_param_value.integer = static_cast<int>(it.second);
            temp_param_value.real = 0.0;
            break;
          case XmlRpc::XmlRpcValue::TypeDouble:
            temp_param_value.integer = 0;
            temp_param_value.real = static_cast<double>(it.second);
            break;
          default:
            ROS_WARN_NAMED("OFFBOARD", "PR: Unsupported XmlRpcValue type: %u", it.second.getType());
          }
          custom_parameters[it.first] = temp_param_value;
        }
      }
    }
  }

  ROS_INFO("OFFBOARD: Custom FCU parameters list loaded!");
}

void OffboardControl::cleanBeforeExit()
{
  ROS_INFO("OFFBOARD: Cleanning OffboardControl ...");
  if (custom_param_seted){
    setFCUParam(origin_paramters_in_fcu);
  }
}

bool OffboardControl::posReached(const Pose& desired_pose)
{
  return (sqrt((local_pose.pose.position.x-desired_pose.pose.position.x)*(local_pose.pose.position.x-desired_pose.pose.position.x)+
    (local_pose.pose.position.y-desired_pose.pose.position.y)*(local_pose.pose.position.y-desired_pose.pose.position.y) +
    (local_pose.pose.position.z-desired_pose.pose.position.z)*(local_pose.pose.position.z-desired_pose.pose.position.z))
  < reached_condition);
}

// void OffboardControl::preemptCB(void) 
// {
//     ROS_INFO("OFFBOARD: %s Preempted", action_server_name.c_str());
//     // set the action state to preempted
//     as_->setPreempted();
// }

bool OffboardControl::yawReached(geometry_msgs::Quaternion const &q_sp)
{
  double yaw_current = tf::getYaw(local_pose.pose.orientation);
  double yaw_sp = tf::getYaw(q_sp);

  if (fabs(yaw_sp - yaw_current) < yaw_reached_condition) return true;
  else return false;
}

geometry_msgs::Point OffboardControl::pose_generate(const geometry_msgs::Point &current_wp, const geometry_msgs::Point &next_wp)
//bool near = cross_sphere_line(pos_s, 1.0f, prev_sp_s, curr_sp_s, pos_sp_s);
{

  tf::Point res;
  tf::Vector3 here_c, line_a, line_b;
  tf::pointMsgToTF(local_pose.pose.position, here_c);
  tf::pointMsgToTF(current_wp, line_a);
  tf::pointMsgToTF(next_wp, line_b);

  tf::Vector3 line_cb = line_b - here_c;

  /* project center of sphere on line */
  /* normalized AB */
  tf::Vector3 ab_norm = line_b - line_a;

  if (ab_norm.length() < 0.01) { /* way points are two close */
    res = here_c + ((line_b - here_c).normalized() * sphere_r);
  } else {

    ab_norm.normalize();
    tf::Vector3 d = line_a + ab_norm * (here_c - line_a).dot(ab_norm);
    float cd_len = (here_c - d).length();

    if (sphere_r > cd_len) {
      /* we have triangle CDX with known CD and CX = R, find DX */
      float dx_len = sqrtf(sphere_r * sphere_r - cd_len * cd_len);
        
      if ((here_c - line_b).length() < sphere_r) { /* target is near */
        res = line_b;
      } else if ((here_c - line_b).dot(ab_norm) > 0.0) {/* target waypoint is already behind us */
        res = here_c + ((line_b - here_c).normalized() * sphere_r);
      } else {
        /* target is in front of us */
        res = d + ab_norm * dx_len; // vector A->B on line
      }
    } else {
      /* have no roots, return D */
      res = here_c + ((d - here_c).normalized() * sphere_r); /* go directly to line */

      /* previous waypoint is still in front of us */
      if ((here_c - line_a).dot(ab_norm) < 0.0) {
        res = here_c + ((line_a - here_c).normalized() * sphere_r);
      }
      /* target waypoint is already behind us */
      if ((here_c - line_b).dot(ab_norm) > 0.0) {
        res = here_c + ((line_b - here_c).normalized() * sphere_r);
      }
    }
    geometry_msgs::Point desired_point;
    tf::pointTFToMsg(res,desired_point);
    return desired_point;
  }
}

bool OffboardControl::isQuaternionValid(const geometry_msgs::Quaternion& q)
{
  //first we need to check if the quaternion has nan's or infs
  if(!std::isfinite(q.x) || !std::isfinite(q.y) || !std::isfinite(q.z) || !std::isfinite(q.w)){
    ROS_ERROR("Quaternion has nans or infs... discarding as a navigation goal");
    return false;
  }

  tf::Quaternion tf_q(q.x, q.y, q.z, q.w);

  //next, we need to check if the length of the quaternion is close to zero
  if(tf_q.length2() < 1e-6){
    ROS_ERROR("Quaternion has length close to zero... discarding as navigation goal");
    return false;
  }
  /* disable vertical check --bdai */
  // //next, we'll normalize the quaternion and check that it transforms the vertical vector correctly
  // tf_q.normalize();

  // tf::Vector3 up(0, 0, 1);

  // double dot = up.dot(up.rotate(tf_q.getAxis(), tf_q.getAngle()));

  // if(fabs(dot - 1) > 1e-3){
  //   ROS_ERROR("Quaternion is invalid... for navigation the z-axis of the quaternion must be close to vertical.");
  //   return false;
  // }

  return true;
}

void OffboardControl::setFCUParam(std::unordered_map<std::string, mavros_msgs::ParamValue> const& param_dict)
{
  for (auto &it : param_dict) {
    mavros_msgs::ParamSet temp_param_set;
    temp_param_set.request.param_id = it.first;
    temp_param_set.request.value = it.second;
    set_param.call(temp_param_set);
    if (!temp_param_set.response.success){
        ROS_INFO("OFFBOARD: Parameter set error!");
    }
  }
}

void OffboardControl::stateCB(const mavros_msgs::State::ConstPtr& msg)
{
  // update parameters when offboard mode switched in or out
  // if((current_state.mode != "OFFBOARD" && current_state.mode != "POSCTL") &&
  //    (msg->mode == "OFFBOARD" || msg->mode == "POSCTL")) {
  if((current_state.mode != "OFFBOARD") && (msg->mode == "OFFBOARD")) {
    setFCUParam(custom_parameters);
    custom_param_seted = true;
    ROS_WARN("OFFBOARD: Set custom parameters into FCU.");
      
  // } else if((current_state.mode == "OFFBOARD" || current_state.mode == "POSCTL") &&
  //   (msg->mode != "OFFBOARD" && msg->mode != "POSCTL")) {
  } else if((current_state.mode == "OFFBOARD") && (msg->mode != "OFFBOARD")) {
    setFCUParam(origin_paramters_in_fcu);
    ROS_WARN("OFFBOARD: Reset default parameters into FCU.");
    custom_param_seted = false;
  }

  current_state = *msg;
}

void OffboardControl::localPositionCB(const Pose::ConstPtr& msg)
{
  local_pose = *msg;
}

void OffboardControl::localVelocityCB(const Twist::ConstPtr& msg)
{
  local_velocity = *msg;
}


void OffboardControl::executeCB(const offboard_control::PathNavigationGoalConstPtr & goal)
{
  ROS_INFO("OFFBOARD: Get a new goal!");  

  if (goal->path.size() == 0){
    set_pause_pose = false;
    moving_state = MOVING_STATE::PAUSE;
    ROS_WARN("OFFBOARD: Empty waypoint in path, please check desired path!");
    as_->setAborted(result,"Empty waypoint in path, please check desired path!");
    return;
  }
  ros::Rate rate(10);
  int current_number = 0;

  while (!ros::isShuttingDown()) {
    if (as_->isPreemptRequested()) {
      as_->setPreempted();
      ROS_DEBUG_STREAM("OFFBOARD: %s preempt current goal" << action_server_name.c_str());
      set_pause_pose = false;
      moving_state = MOVING_STATE::PAUSE;
      return;
    }

    feedback.current_pose = local_pose;
    as_->publishFeedback(feedback);

    if (!isQuaternionValid(goal->path[current_number].pose.orientation)){
      set_pause_pose = false;
      moving_state = MOVING_STATE::PAUSE;
      as_->setAborted(result,"Aborting, Error quaternion waypoint!");
      ROS_WARN_STREAM("OFFBOARD: Aborting, Error quaternion in " << current_number << "th waypoint!");
      return;
    }

    ROS_DEBUG_STREAM("OFFBOARD: Following " << current_number <<"th waypoint...");
    moving_state = MOVING_STATE::FOLLOW_PATH;
    
    if (!posReached(goal->path[current_number]) || !yawReached(goal->path[current_number].pose.orientation)) {
      if (current_number == 0 ){ // the first waypoint
        set_pose = goal->path[current_number];
      } else {
        set_pose.pose.orientation = goal->path[current_number].pose.orientation;
        set_pose.pose.position = pose_generate(goal->path[current_number-1].pose.position,goal->path[current_number].pose.position);
      }
    } else {
      current_number++;
    }

    if(current_number == goal->path.size()){
      // position reached, set orientation as last waypoint's
      as_->setSucceeded(result, "Finish goal, loiting in last waypoint");
      ROS_INFO("OFFBOARD: Finish goal");
      return;
    }
    rate.sleep();
  }
  as_->setAborted(result, "Aborting on the goal because the node is shutting down");
  ROS_INFO("OFFBOARD: Aborting on the goal because the node is shutting down");
}

void OffboardControl::pubTimerCB(const ros::TimerEvent& event)
{

  if(!current_state.armed) moving_state = MOVING_STATE::INIT;
  else moving_state = MOVING_STATE::PAUSE;

  switch (moving_state) {

    case MOVING_STATE::PAUSE:
      if (!set_pause_pose) {
        set_pose = local_pose;
        set_pause_pose = true;
      }
      set_position_pub.publish(set_pose);
      break;

    // case MOVING_STATE::FOLLOW_POS:
    //   set_position_pub.publish(set_pose);
    //   break;

    case MOVING_STATE::INIT:
    default: 
      set_pose = local_pose;
      set_position_pub.publish(set_pose);
      break;

    // case MOVING_STATE::FOLLOW_VEL:
    //   set_velocity_pub.publish(set_vel);
    //   break;

    case MOVING_STATE::FOLLOW_PATH:
      set_position_pub.publish(set_pose);
      break;
   
  }
}

void OffboardControl::spin()
{
  // wait for FCU connection
  while(ros::ok() && !current_state.connected ){
      ros::spinOnce();
      ROS_INFO("OFFBOARD: Wait for FCU connection!");
      rate_wait.sleep();
  }

  updateParamList();

	ros::AsyncSpinner spinner(4 /* threads */);
	auto control_pub_timer = private_nh.createTimer(
			ros::Duration(1.0/pub_frequency), /* set as frequency */
			&OffboardControl::pubTimerCB, this);

	control_pub_timer.start();

	spinner.start();
	ros::waitForShutdown();

  ROS_INFO("OFFBOARD: Stopping OffboardControl...");
	spinner.stop();
}

static OffboardControl* offboard_control_ptr = nullptr;

static void sigintHandle(int sig)
{
  ROS_INFO("OFFBOARD: Processing clean work before shutdown!");
  if (offboard_control_ptr != nullptr){
    // delete offboard_control_ptr; // call deconstructor
    offboard_control_ptr->cleanBeforeExit();
  }
  ros::param::set("/is_offboard_node_alive",false);
  ros::shutdown();
}

int main(int argc, char **argv)
{
  /* code */
  ros::init(argc, argv, "offboard_tracking", ros::init_options::NoSigintHandler);

  signal(SIGINT, sigintHandle);

  ros::param::set("/is_offboard_node_alive",true);

  offboard_control_ptr = new OffboardControl;
  offboard_control_ptr->spin();
  return 0;
}
